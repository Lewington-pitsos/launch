/*
the player object is responsible for generating moves. Because of this it needs to be aware of the board object (so it knows which moves are legal).
additionally:
  token => it must remember which token it is playing as.
  border => should keep track of the board edges
  placeAt => must be able to modify the board by placing a single token
  edgeTest => requires a means of comparing moves to board edges
  move => just transfers decisions as generated by Computer or Human players to placeAt. It's only to make things easier to parse and will probably be eliminated.
*/
function Player(board, token) {
  this.board = board;
  this.token = token;
  this.border = function() {
    return this.board.length;
  }

  this.placeAt = function (coordinates) {
    this.board[coordinates[0]][coordinates[1]] = this.token;
  }

  this.edgeTest = function(coordinates){
    return (coordinates[0] < this.border() && coordinates[1] < this.border());
  }

  this.move = function(){
    var input = this.chooseSpace();
    this.placeAt(input);
  }
}

/*
Both Human and Computer players have a different chooseSpace method by which they decide where to move next. The Human chooseSpace is very simpl.e it merely prompts the user for a move.
*/

function Human(board, token) {
  Player.call(this, board, token);

  this.chooseSpace = function() {
    var input = [Number(prompt('choose a row index')), Number(prompt('choose a clumn index'))];
    if (this.edgeTest(input)) {
      return input;
    } else {
      return this.chooseSpace;
    }
  }
}

/*
Computer players will eventually have a somewhat complciated process for choosing each move, but for now they simply choose one square that isn't beyond the bounds of the board.
*/

function Computer(board, token) {
  Player.call(this, board, token);

  this.chooseSpace = function() {
    edge = this.border() - 1;
    var row = Math.floor(Math.random() * edge);
    var col = Math.floor(Math.random() * edge);
    return [row, col];
  }
}
